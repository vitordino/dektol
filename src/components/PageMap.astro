<div class="page-map-wrapper">
  <slot />
  <div class="page-map-canvas-wrapper">
    <canvas class="page-map-canvas"></canvas>
    <div class="page-map-brush-left"></div>
    <div class="page-map-brush-right"></div>
    <div class="page-map-brush-handle"></div>
  </div>
</div>

<script hoist>
  const padding = 64
  const y = 32
  const height = 2
  const wrapperSelector = '.page-map-wrapper'
  const canvasSelector = '.page-map-canvas'
  const itemSelector = '[data-map="item"]'
  const containerSelector = '[data-map="container"]'
  const leftBrushSelector = '.page-map-brush-left'
  const rightBrushSelector = '.page-map-brush-right'
  const brushHandleSelector = '.page-map-brush-handle'
  const middleSelector = '.horizontal-scroll-middle'

  const getRelativeRect = (totalWidth, viewportWidth, { x, width }) => {
    const paddedViewportWidth = viewportWidth - 2 * padding
    const paddedTotalWidth = totalWidth - 2 * padding
    const outputX = ((x - padding) / paddedTotalWidth) * paddedViewportWidth + padding
    const outputWidth = (width / paddedTotalWidth) * paddedViewportWidth
    return [outputX, y, outputWidth, height]
  }

  const wrappers = [...document.querySelectorAll(wrapperSelector)]

  const drawLines = () => {
    const dpi = window.devicePixelRatio
    wrappers.forEach(wrapper => {
      const canvas = wrapper.querySelector(canvasSelector)
      const container = wrapper.querySelector(containerSelector)
      const items = [...wrapper.querySelectorAll(itemSelector)]

      const totalWidth = Math.max(container.scrollWidth, container.clientWidth)
      const viewportWidth = canvas.clientWidth
      const getRelativeContextRect = rect => getRelativeRect(totalWidth, viewportWidth, rect)

      const context = canvas.getContext('2d')
      canvas.width = canvas.clientWidth * dpi
      canvas.height = canvas.clientHeight * dpi
      context.scale(dpi, dpi)

      const rects = items.map(x => getRelativeContextRect(x.getBoundingClientRect()))

      context.clearRect(0, 0, canvas.width, canvas.height)
      context.fillStyle = '00ff00'

      rects.forEach(rect => {
        context.beginPath()
        context.rect(...rect)
        context.fill()
      })
    })
  }

  const normalizeScale = n => Math.min(Math.max(n, 0), 1)

  const drawBrushes = () => {
    wrappers.forEach(wrapper => {
      const container = wrapper.querySelector(containerSelector)
      const middle = wrapper.querySelector(middleSelector)
      const containerRect = container.getBoundingClientRect()
      const initialY = containerRect.y
      const { y } = middle.getBoundingClientRect()

      const leftBrush = wrapper.querySelector(leftBrushSelector)
      const rightBrush = wrapper.querySelector(rightBrushSelector)

      const totalWidth = Math.max(container.scrollWidth, container.clientWidth)
      const viewportWidth = window.innerWidth
      const scaleLeft = (-y - initialY - padding) / (totalWidth - 2 * padding)
      const scaleRight = 1 - viewportWidth / (totalWidth - 2 * padding) - scaleLeft

      leftBrush.style.transform = `scaleX(${normalizeScale(scaleLeft)})`
      rightBrush.style.transform = `scaleX(${normalizeScale(scaleRight)})`
    })
  }

  const brushMouseHandles = () => {
    wrappers.forEach(wrapper => {
      const container = wrapper.querySelector(containerSelector)
      const middle = wrapper.querySelector(middleSelector)
      const containerRect = container.getBoundingClientRect()
      const initialY = containerRect.y
      const totalWidth = Math.max(container.scrollWidth, container.clientWidth)
      const viewportWidth = window.innerWidth
      const { y } = middle.getBoundingClientRect()
      const brushHandleElement = wrapper.querySelector(brushHandleSelector)

      const getVerticalScroll = x =>
        initialY +
        (x / (viewportWidth - padding)) * (totalWidth - 2 * padding) +
        ((x - initialY) / (viewportWidth - padding)) * padding * 2 -
        (viewportWidth * viewportWidth) / viewportWidth / 2

      const RightYBound = initialY + totalWidth - viewportWidth - 1
      const getBoundedVerticalScroll = x =>
        Math.min(Math.max(getVerticalScroll(x), initialY), RightYBound)

      const onDrag = ({ clientX }) => {
        console.log({ clientX, viewportWidth, totalWidth, y, initialY })
        const newScroll = getBoundedVerticalScroll(clientX)
        // console.log('onDrag', { clientX, newScroll })
        document.documentElement.scrollTop = newScroll
      }

      const onDragEnd = () => {
        brushHandleElement.style.cursor = 'grab'
        document.documentElement.style.cursor = 'auto'
        document.documentElement.style.pointerEvents = 'auto'
        document.documentElement.removeEventListener('mouseup', onDragEnd)
        document.documentElement.removeEventListener('mousemove', onDrag)
        window.removeEventListener('mousemove', onDrag)
        brushHandleElement.addEventListener('mouseup', onDragStart)
        // console.log('onDragEnd')
        wrapper.removeAttribute('data-dragging')
      }

      const onDragStart = ({ x }) => {
        brushHandleElement.style.cursor = 'grabbing'
        document.documentElement.style.cursor = 'grabbing'
        document.documentElement.style.pointerEvents = 'none'
        brushHandleElement.removeEventListener('mouseup', onDragStart)
        document.documentElement.addEventListener('mouseup', onDragEnd)
        document.documentElement.addEventListener('mousemove', onDrag)
        window.addEventListener('mousemove', onDrag)
        // console.log('onDragStart')
        document.documentElement.scrollTop = getBoundedVerticalScroll(x)
        wrapper.setAttribute('data-dragging', 'true')
      }
      brushHandleElement.addEventListener('mousedown', onDragStart)
    })
  }

  brushMouseHandles()

  drawLines()
  window.addEventListener('resize', drawLines)

  drawBrushes()
  window.addEventListener('scroll', drawBrushes)
</script>

<style global>
  .page-map-canvas-wrapper {
    display: none;
  }
  @media (min-width: 720px) {
    .page-map-wrapper {
      position: relative;
    }

    .page-map-canvas-wrapper {
      display: block;
      position: sticky;
      bottom: 0;
      height: 0;
      width: 100%;
      transition: 0.3s opacity;
    }

    .page-map-canvas {
      position: absolute;
      bottom: 0;
      height: 64px;
      width: 100%;
    }
    .horizontal-scroll-wrapper[data-sticky='false'] ~ .page-map-canvas-wrapper {
      pointer-events: none;
      opacity: 0;
      transition: 0.15s opacity;
    }
    .horizontal-scroll-wrapper[data-sticky='true'] ~ .page-map-canvas-wrapper {
      pointer-events: auto;
      opacity: 1;
    }

    html[data-dragging='true'] ~ .page-map-canvas-wrapper {
      pointer-events: auto;
      opacity: 1;
    }

    .page-map-brush-left,
    .page-map-brush-right {
      position: absolute;
      bottom: 0;
      height: 64px;
      width: calc(100% - 128px);
      background: #fff;
      transform-origin: left;
      left: 64px;
      opacity: 0.8;
    }
    .page-map-brush-right {
      transform-origin: right;
    }

    .page-map-brush-handle {
      position: absolute;
      bottom: 0;
      height: 64px;
      left: 0;
      right: 0;
      cursor: grab;
    }
  }
</style>
